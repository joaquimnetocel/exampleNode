# COMPARISON PECULIARITIES

HERE WE'LL LEARN MORE ABOUT DIFFERENT TYPES OF COMPARISONS, HOW JAVASCRIPT MAKES THEM, INCLUDING IMPORTANT PECULIARITIES.

AT THE END YOU'LL FIND A GOOD RECIPE TO AVOID "JAVASCRIPT QUIRKS"-RELATED ISSUES.

## COMPARISON WITH `null` AND `undefined`

THERE'S A NON-INTUITIVE BEHAVIOR WHEN `null` OR `undefined` ARE COMPARED TO OTHER VALUES.

* **FOR A STRICT EQUALITY CHECK:**

  ```javascript
  console.log( null === undefined ); // THESE VALUES ARE DIFFERENT, BECAUSE EACH OF THEM IS A DIFFERENT TYPE.
  ```

* **FOR A NON-STRICT CHECK:**

  ```javascript
  console.log( null == undefined ); // SHOWS true 
  ```

* **FOR MATHS AND OTHER COMPARISONS (`<` `>` `<=` `>=`):**

  NULL/UNDEFINED ARE CONVERTED TO NUMBERS: `null` BECOMES `0`, WHILE `undefined` BECOMES `NAN`.

NOW LET'S SEE SOME FUNNY THINGS THAT HAPPEN WHEN WE APPLY THESE RULES. AND, WHAT'S MORE IMPORTANT, HOW TO NOT FALL INTO A TRAP WITH THEM.

## STRANGE RESULT: `null` VS `0`

LET'S COMPARE `null` WITH `0`:

```javascript
console.log( null > 0 ); // SHOWS false
console.log( null == 0 ); // SHOWS false
console.log( null >= 0 ); // SHOWS true
```

MATHEMATICALLY, THAT'S STRANGE. THE LAST RESULT STATES THAT "NULL IS GREATER THAN OR EQUAL TO ZERO", SO IN ONE OF THE COMPARISONS ABOVE IT MUST BE TRUE, BUT THEY ARE BOTH FALSE.

THE REASON IS THAT AN EQUALITY CHECK `==` AND COMPARISONS (`>`, `<`, `>=`, `<=`) WORK DIFFERENTLY. COMPARISONS CONVERT `null` TO A NUMBER, TREATING IT AS `0`. THAT'S WHY `null >= 0` IS `true` AND `null > 0` IS `false`.

ON THE OTHER HAND, THE EQUALITY CHECK `==` FOR `undefined` AND `null` IS DEFINED SUCH THAT, WITHOUT ANY CONVERSIONS, THEY EQUAL EACH OTHER AND DON'T EQUAL ANYTHING ELSE. THAT'S WHY `null == 0` IS `false`.

## AN INCOMPARABLE UNDEFINED

THE VALUE UNDEFINED SHOULDN'T BE COMPARED TO OTHER VALUES:

```javascript
console.log(undefined > 0); // SHOWS false (1)
console.log(undefined < 0); // SHOWS false (2)
console.log(undefined == 0); // SHOWS false (3)
```

WHY DOES IT DISLIKE ZERO SO MUCH? ALWAYS FALSE! WE GET THESE RESULTS BECAUSE:

* THE FIRST TWO COMPARISONS RETURN `false` BECAUSE `undefined` GETS CONVERTED TO `NaN` AND `NaN` IS A SPECIAL NUMERIC VALUE WHICH RETURNS `false` FOR ALL COMPARISONS.
* THE THIRD EQUALITY CHECK RETURNS `false` BECAUSE `undefined` ONLY EQUALS `null`, `undefined` AND NO OTHER VALUE.

## AVOID PROBLEMS

WHY DID WE GO OVER THESE EXAMPLES? SHOULD WE REMEMBER THESE PECULIARITIES ALL THE TIME? WELL, NOT REALLY. ACTUALLY, THESE TRICKY THINGS WILL GRADUALLY BECOME FAMILIAR OVER TIME, BUT THERE'S A SOLID WAY TO AVOID PROBLEMS WITH THEM:

* TREAT ANY COMPARISON WITH UNDEFINED/NULL (EXCEPT THE STRICT EQUALITY) WITH EXCEPTIONAL CARE.
* DON'T USE COMPARISONS (`>=`, `>`, `<`,  `<=`) WITH A VARIABLE WHICH MAY BE NULL/UNDEFINED, UNLESS YOU'RE REALLY SURE OF WHAT YOU'RE DOING. IF A VARIABLE CAN HAVE THESE VALUES, CHECK FOR THEM SEPARATELY.
